diff --git a/tests/threads/Make.tests b/tests/threads/Make.tests
index fd03db8..ee78e13 100644
--- a/tests/threads/Make.tests
+++ b/tests/threads/Make.tests
@@ -9,7 +9,7 @@ priority-donate-nest priority-donate-sema priority-donate-lower		\
 priority-fifo priority-preempt priority-sema priority-condvar		\
 priority-donate-chain                                                   \
 mlfqs-load-1 mlfqs-load-60 mlfqs-load-avg mlfqs-recent-1 mlfqs-fair-2	\
-mlfqs-fair-20 mlfqs-nice-2 mlfqs-nice-10 mlfqs-block my_test)
+mlfqs-fair-20 mlfqs-nice-2 mlfqs-nice-10 mlfqs-block my_test my_test_create_threads my_test_synch_sema my_test_synch_lock my_test_producer_consumer)
 
 # Sources for tests.
 tests/threads_SRC  = tests/threads/tests.c
@@ -38,6 +38,9 @@ tests/threads_SRC += tests/threads/mlfqs-fair.c
 tests/threads_SRC += tests/threads/mlfqs-block.c
 tests/threads_SRC += tests/threads/my_test.c
 tests/threads_SRC += tests/threads/my_test_create_threads.c
+tests/threads_SRC += tests/threads/my_test_synch_sema.c
+tests/threads_SRC += tests/threads/my_test_synch_lock.c
+tests/threads_SRC += tests/threads/my_test_producer_consumer.c
 
 MLFQS_OUTPUTS = 				\
 tests/threads/mlfqs-load-1.output		\
diff --git a/tests/threads/my_test_create_threads.c b/tests/threads/my_test_create_threads.c
index eca9214..c017fd8 100644
--- a/tests/threads/my_test_create_threads.c
+++ b/tests/threads/my_test_create_threads.c
@@ -16,7 +16,7 @@ void thread_body(void *param){
     print_thread_info(thread_current());
 }
 
-void my_test_create_threads(void *param){
+void my_test_create_threads(void){
     tid_t t[6];
     for(int i=1;i<=5;i++)
     {
diff --git a/tests/threads/tests.c b/tests/threads/tests.c
index 1e9c649..1685ad7 100644
--- a/tests/threads/tests.c
+++ b/tests/threads/tests.c
@@ -40,6 +40,9 @@ static struct test tests[] =
     {"mlfqs-block", test_mlfqs_block},
     {"my_test ", my_test },
     {"my_test_create_threads", my_test_create_threads },
+    {"my_test_synch_sema", my_test_synch_sema},
+    {"my_test_synch_lock", my_test_synch_lock},
+    {"my_test_producer_consumer", my_test_producer_consumer},
   };
 
 static const char *test_name;
@@ -140,6 +143,16 @@ run_test (const char *name)
 
   tests[28].name = "my_test_create_threads";
   tests[28].function = my_test_create_threads;
+
+  tests[29].name = "my_test_synch_sema";
+  tests[29].function = my_test_synch_sema;
+
+  tests[30].name = "my_test_synch_lock";
+  tests[30].function = my_test_synch_lock;
+
+  tests[31].name = "my_test_producer_consumer";
+  tests[31].function = my_test_producer_consumer;
+
   // END - added at UTCN (2018)
 
   for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
diff --git a/tests/threads/tests.h b/tests/threads/tests.h
index d7c0bd4..e7f533d 100644
--- a/tests/threads/tests.h
+++ b/tests/threads/tests.h
@@ -34,6 +34,9 @@ extern test_func test_mlfqs_nice_10;
 extern test_func test_mlfqs_block;
 extern test_func my_test;
 extern test_func my_test_create_threads;
+extern test_func my_test_synch_sema;
+extern test_func my_test_synch_lock;
+extern test_func my_test_producer_consumer;
 
 void msg (const char *, ...);
 void fail (const char *, ...);
diff --git a/threads/synch.c b/threads/synch.c
index 317c68a..a6014d1 100644
--- a/threads/synch.c
+++ b/threads/synch.c
@@ -48,8 +48,19 @@ sema_init (struct semaphore *sema, unsigned value)
 
   sema->value = value;
   list_init (&sema->waiters);
+  sema->name = "noname";
 }
 
+void sema_init_name(struct semaphore *sema, unsigned value, const char *name)
+{
+  ASSERT (sema != NULL);
+
+  sema->value = value;
+  list_init (&sema->waiters);
+  sema->name = name;
+}
+
+
 /* Down or "P" operation on a semaphore.  Waits for SEMA's value
    to become positive and then atomically decrements it.
 
@@ -60,6 +71,8 @@ sema_init (struct semaphore *sema, unsigned value)
 void
 sema_down (struct semaphore *sema) 
 {
+  if (strcmp(sema->name,"noname")!=0)
+    printf("\n--DOWN Semaphore named: %s called by thread with tid: %ld--\n", sema->name, (long)thread_current()->tid);
   enum intr_level old_level;
 
   ASSERT (sema != NULL);
@@ -108,6 +121,9 @@ sema_try_down (struct semaphore *sema)
 void
 sema_up (struct semaphore *sema) 
 {
+  //printf("\n-- Sema UP, name: %s --\n",sema->name);
+  if (strcmp(sema->name,"noname")!=0)
+    printf("\n--UP Semaphore named: %s called by thread with tid: %ld--\n", sema->name, (long)thread_current()->tid);
   enum intr_level old_level;
 
   ASSERT (sema != NULL);
@@ -179,8 +195,17 @@ lock_init (struct lock *lock)
 
   lock->holder = NULL;
   sema_init (&lock->semaphore, 1);
+  lock->name = "noname";
 }
 
+void lock_init_name(struct lock *lock, const char *name)
+{
+  ASSERT (lock != NULL);
+
+  lock->holder = NULL;
+  sema_init (&lock->semaphore, 1);
+  lock->name = name;
+}
 /* Acquires LOCK, sleeping until it becomes available if
    necessary.  The lock must not already be held by the current
    thread.
@@ -200,6 +225,22 @@ lock_acquire (struct lock *lock)
   lock->holder = thread_current ();
 }
 
+void lock_acquire_V2(struct lock *lock)
+{
+   /*enum intr_level old_level;
+
+  ASSERT (lock != NULL);
+  ASSERT (!intr_context ());
+
+  old_level = intr_disable ();
+  while (sema->value == 0) 
+    {
+      list_push_back (&sema->waiters, &thread_current ()->elem);
+      thread_block ();
+    }
+  sema->value--;
+  intr_set_level (old_level);*/
+}
 /* Tries to acquires LOCK and returns true if successful or false
    on failure.  The lock must not already be held by the current
    thread.
@@ -235,6 +276,20 @@ lock_release (struct lock *lock)
   sema_up (&lock->semaphore);
 }
 
+void lock_release_V2(struct lock *lock)
+{
+  /*enum intr_level old_level;
+
+  ASSERT (lock != NULL);
+
+  old_level = intr_disable ();
+  if (!list_empty (lock->semaphore->waiters)) 
+    thread_unblock (list_entry (list_pop_front (&sema->waiters),
+                                struct thread, elem));
+  sema->value++;
+  intr_set_level (old_level);*/
+}
+
 /* Returns true if the current thread holds LOCK, false
    otherwise.  (Note that testing whether some other thread holds
    a lock would be racy.) */
diff --git a/threads/synch.h b/threads/synch.h
index a19e88b..caed86b 100644
--- a/threads/synch.h
+++ b/threads/synch.h
@@ -9,9 +9,11 @@ struct semaphore
   {
     unsigned value;             /* Current value. */
     struct list waiters;        /* List of waiting threads. */
+    char *name;       
   };
 
 void sema_init (struct semaphore *, unsigned value);
+void sema_init_name(struct semaphore *, unsigned value, const char *name);
 void sema_down (struct semaphore *);
 bool sema_try_down (struct semaphore *);
 void sema_up (struct semaphore *);
@@ -22,14 +24,19 @@ struct lock
   {
     struct thread *holder;      /* Thread holding lock (for debugging). */
     struct semaphore semaphore; /* Binary semaphore controlling access. */
+    char *name;
   };
 
 void lock_init (struct lock *);
+void lock_init_name(struct lock *, const char *name);
 void lock_acquire (struct lock *);
 bool lock_try_acquire (struct lock *);
 void lock_release (struct lock *);
 bool lock_held_by_current_thread (const struct lock *);
 
+void lock_acquire_V2(struct lock *);
+void lock_release_V2(struct lock *);
+
 /* Condition variable. */
 struct condition 
   {
diff --git a/threads/thread.c b/threads/thread.c
index 67dc61d..03ad7ae 100644
--- a/threads/thread.c
+++ b/threads/thread.c
@@ -571,9 +571,7 @@ schedule (void)
 }
 
 void print_thread_info(struct thread* the_thread){
-  printf("\n Name thread = %s \n",the_thread->name);
-  printf("\n Tid thread = %d \n",the_thread->tid);
-  printf("\n State thread = %d \n",the_thread->status);
+  printf("\n Name thread = %s ,Tid thread = %ld, State thread = %d \n",the_thread->name, (long)the_thread->tid, the_thread->status);
 }
 
 /* Returns a tid to use for a new thread. */
@@ -585,6 +583,8 @@ allocate_tid (void)
 
   lock_acquire (&tid_lock);
   tid = next_tid++;
+  //next_tid = next_tid*3;
+  //tid = next_tid;
   lock_release (&tid_lock);
 
   return tid;
